<?xml version='1.0' encoding='utf-8'?>
<class abstract="true" id="json::AbstractObject" name="AbstractObject" xmlns="http://jessevdk.github.com/cldoc/1.0">
  <brief> node ins the tree structure</brief>
  <doc>![v√©rsiole](./pics/AbstractObjectHierarchy.gif)



</doc>
  <subclass access="public" name="ObjectContainer" ref="json::ObjectContainer#json::ObjectContainer" />
  <subclass access="public" name="ObjectFinal" ref="json::ObjectFinal#json::ObjectFinal" />
  <destructor abstract="yes" id="json::AbstractObject::~AbstractObject" name="~AbstractObject" virtual="yes" />
  <method abstract="yes" id="json::AbstractObject::add" name="add" virtual="yes">
    <brief> Add method</brief>
    <doc>Reimplementations of this method try to add 'obj' as a son of the
node at 'path'. (<ref ref="json::ObjectContainer#json::ObjectContainer">json::ObjectContainer</ref> derived classes have a working
method while <ref ref="json::ObjectFinal#json::ObjectFinal">json::ObjectFinal</ref> have not; a final can not be father of other node)

</doc>
    <return>
      <doc>the operation is successfuly finished or not</doc>
      <type builtin="yes" name="bool" />
    </return>
    <argument id="json::AbstractObject::add::path" name="path">
      <doc>route to the node to be father of 'obj'</doc>
      <type name="std::__cxx11::string" />
    </argument>
    <argument id="json::AbstractObject::add::obj" name="obj">
      <doc>node to be added</doc>
      <type name="AbstractObject" qualifier="*" ref="json::AbstractObject#json::AbstractObject" />
    </argument>
  </method>
  <method abstract="yes" id="json::AbstractObject::copy" name="copy" static="yes">
    <return>
      <type name="AbstractObject" qualifier="*" ref="json::AbstractObject#json::AbstractObject" />
    </return>
    <argument id="json::AbstractObject::copy::obj" name="obj">
      <type name="AbstractObject" qualifier="*" ref="json::AbstractObject#json::AbstractObject" />
    </argument>
  </method>
  <method abstract="yes" id="json::AbstractObject::get" name="get" virtual="yes">
    <brief> Accessor method</brief>
    <doc>Reimplementations of this method try to reach the node at 'path'.
(<ref ref="json::ObjectContainer#json::ObjectContainer">json::ObjectContainer</ref> derived classes have a working reimplementation
while <ref ref="json::ObjectFinal#json::ObjectFinal">json::ObjectFinal</ref> have not; a final can not be father of other node)

</doc>
    <return>
      <doc>nullptr if node does not exist, the pointer to the node otherwise</doc>
      <type name="AbstractObject" qualifier="*" ref="json::AbstractObject#json::AbstractObject" />
    </return>
    <argument id="json::AbstractObject::get::path" name="path">
      <doc>route to the element</doc>
      <type name="std::__cxx11::string" />
    </argument>
  </method>
  <method abstract="yes" id="json::AbstractObject::getName" name="getName" virtual="yes">
    <brief> Get node tye name</brief>
    <doc>Used for console debugging of <ref ref="json::JsonTree#json::JsonTree">json::JsonTree</ref> management errors

</doc>
    <return>
      <doc>class name</doc>
      <type builtin="yes" name="char" qualifier=" const *" />
    </return>
  </method>
  <method abstract="yes" id="json::AbstractObject::toTxt" name="toTxt" virtual="yes">
    <brief> Generates pretty json text</brief>
    <doc>Reimplementations of this method recursively generate the text version in
json format of the content both node and sons, appending it to 'txt' parameter.
The string respects the indentation and is human readable
</doc>
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="json::AbstractObject::toTxt::txt" name="txt">
      <doc>string to append this node info</doc>
      <type name="std::__cxx11::string" qualifier=" &amp;" />
    </argument>
    <argument id="json::AbstractObject::toTxt::indentLvl" name="indentLvl">
      <doc>number of indentations to generate a consistent string</doc>
      <type builtin="yes" name="int" />
    </argument>
  </method>
  <method abstract="yes" id="json::AbstractObject::toTxtUgly" name="toTxtUgly" virtual="yes">
    <brief> Generates ugly json text</brief>
    <doc>Reimplementations of this method recursively generate the text version in
json format of the content both node and sons, appending it to 'txt' parameter.
The string is compressed and uglified
</doc>
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="json::AbstractObject::toTxtUgly::txt" name="txt">
      <doc>string to append this node info</doc>
      <type name="std::__cxx11::string" qualifier=" &amp;" />
    </argument>
  </method>
  <method abstract="yes" id="json::AbstractObject::txtIndent" name="txtIndent">
    <brief> Appends whitespaces to string</brief>
    <doc>Simply appends _INDENT_ content 'indentLvl' times to 'txt'.
(two spaces is an indentation as defined in the macro)

#### Macro
```c++
#define INDENT "  "
```
</doc>
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="json::AbstractObject::txtIndent::txt" name="txt">
      <doc>string to append the spaces</doc>
      <type name="std::__cxx11::string" qualifier=" &amp;" />
    </argument>
    <argument id="json::AbstractObject::txtIndent::indentLvl" name="indentLvl">
      <doc>number of indentations</doc>
      <type builtin="yes" name="int" />
    </argument>
  </method>
  <constructor access="protected" id="json::AbstractObject::AbstractObject" name="AbstractObject" />
</class>
